Merge Sort
1.	分割
A.	將一組含有N個項目的數列，以「N/2」方式分割其長度，所以數列會分割成兩組，以「N/2」的商當作分割點的索引，左邊的數列範圍為原數列的起始索引到分割點的前一項索引；右邊的數列範圍為分割點的索引到原數列的尾端索引。
B.	接著，左右兩組分別繼續進行分割，直到數量的長度為1為止。
  
2.	合併與排序
將分割後長度「1」的數列成對地合併並進行排序，直到合併成一組長度與最初數列一樣的數列，而該數列的數值則按照大小順序排序。
A.	見樹狀圖，最初在數列合併時會先從樹狀圖最底層長度「1」的數列開始合併	
B.	而每次在合併時會同時進行排序，首先，會有兩個指標指向欲合併的兩個數列起始數值；其次，兩個指標指向的數值進行比較，較小的數值將會作為合併後數列的起始值；接著，前一次有較小數值的數列的指標會指向該數列的下一個數值與另一個數列的指標所指向的數值繼續比較，較小的數值將會作為合併後數列的下一個數值。以此類推，直到某一個數列的指標超過數列範圍為止；最後，指標未指完的數列的數值再依序作為合併後數列的數值。
C.	上述過程為一次的合併與排序。完全分割的數列會不斷進行上述的合併與排序，直到合併成一組長度與最初數列一樣的數列。
  
以下為程式完成Merge Sort所需的步驟:
1.	第54~58行。如果輸入的數列是非遞迴的程式，則會檢查所輸入的數列裡的個數。其中會用Check函式判斷輸入的數列是否為遞迴的程式，依據為該數列裡是否存在子數列。如果是遞迴的程式，數列存在子數列，該數列的維度 (shape) 會為2；如果是非遞迴的程式，則不存在子數列，數列的維度 (shape) 則為1。檢查所輸入的數列裡的個數方面，個數為0時輸出”no element in the list”；個數為1時則直接輸出陣列。
2.	第59行。利用Sup函式將輸入的數列裡的數值個數補成2的n次方個。其中填補的數值為所輸入的數列中最大的數值加上一。
3.	第60行。將所輸入的數列運用Convert函數將數列中的每個數值都變成一個子數列，每個子數列長度為1，例如將 [3,2,1,4] 轉換成 [[3],[2],[1],[4]]。
4.	第67到72行。將數列裡的子數列兩兩一組透過Merge函式做合併排序，合併排序的原理與流程圖相同，再將所有合併排序過的子數列append到一個空的母數列中。例如將[[3],[2],[1],[4]]的兩兩子數列做合併排序並append到一個空的母數列後會變成 [[2,3],[1,4]]。其中因為陣列的子數列個數永遠一直都保持在2的n次方個，所以每個子數列都能兩兩湊對。
5.	第73行。將子數列做過一次合併排序過的母數列用遞迴的方式繼續做合併排序，其中遞迴的程式都不會經過第54~60行。
6.	第61~66行。經不斷遞迴進行合併排序後，子數列會被合併成一個子數列，而該子數列中已包含最初輸入的數列裡所有的數值並完成排序。此時會將該子數列取出，並把最初填補的值從該數列中刪除，然後輸出該數列，完成Merge Sort所有步驟。
  
Heap Sort  
Heap Sort的原理是先將數列排成堆積樹的形態，將位於樹根節點的數值與位於最後一個子節點的數值對調，再將對掉到最後一個子節點的數值剔除，作為新數列的第一順位，完成一次的Heap Sort排列。接著，因為原本堆積樹型態的數列已經剔除了位於最後一個節點的數值並且原本位於樹根的數值也被移往最後一個節點的位置，因此原本堆積樹的型態已被破壞掉，此時將位於數根的數值向下依序與其較小的子節點比較，當該數值大於子節點時，兩數值則互換，互換後原位於數根的數值再繼續與更下層較小的子節點比較，直到比到最後一個節點為止，全部比較完後再將位於樹根節點的數值與位於最後一個子節點的數值對調，並將對調到最後一個子節點的數值剔除，排進新數列的第二順位。以此類堆，直到堆積樹型態的數列的數值完全被剔除，都被排到新數列中。而此時的新數列將會是一個經大小排序過的數列。  
以Min Heap Tree為例，堆積樹的型態分成根節點、父節點、子節點三個元素。根節點為該數列的最小值並且位於數量的首端，而每個父節點底下連接最多兩個，最少一個子節點，並且父節點的數值必須小於子節點的數值。
  
以下為Heap Sort程式碼的所有步驟:
i.	第3、4行。檢查所輸入的數列是否為空，如果為空數列則輸出
no element in the list。
ii.	增加一個數值在輸入的數列中的最前面，該新增的數值會是原數列中最小的數值減掉1。
iii.	第7~10行。將數列排序成堆積樹型態，接著將樹根與最後的子節點對調，然後把調換到最後節點的數值從堆積樹型態的數列中剔除，另外再額外創一個新的空陣列，將剔除的數值放到新的陣列中，該數值則作為這個新陣列的首位數值。  
其中堆積樹排序的方式是透過Tree函式進行排序，其原理是從數列的樹根由上往下排序，讓每個父節點都小於子節點。因此由上到下依序訪尋到每個節點時 (第17行) ，都要從該節點開始由下至上運用該節點的index除2的商來走訪所有父節點，直到走訪到樹根節點的下一個節點為止 (第18~20行、21行、23行) 。走訪時依序與父節點比較大小，如果走訪到的節點小於其父節點，該節點就與其父節點對調 (第22、24行) 。  
iv.	第10~12行。將位於數根的數值向下依序與其較小的子節點比較，當該數值大於子節點時，兩數值則互換，互換後原位於數根的數值再繼續與更下層較小的子節點比較，直到比到最後一個節點為止，全部比較完後再將位於樹根節點的數值與位於最後一個子節點的數值對調，並將對調到最後一個子節點的數值剔除，排進新數列中。每次都用DeleteMin這個函式來完成。  













