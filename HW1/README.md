快速排序法 (Quick Sort) 會先在資料中任意找一個值作為中間值，把小於中間值的資料放在左邊而把大於中間值的資料放右邊，再以同樣的方式分別處理左右兩邊的資料，直到完成為止。
該方法是目前公認最佳的排序法。  
最快的情況下，時間複雜度為 𝑂(𝑛log 2(𝑛))。  
最壞情況，每次挑中的中間值是最大或最小，時間複雜度為 𝑂(2n)。  
  
將資料「35, 40, 86, 54, 16, 63, 75, 21」使用快速排序法進行由小而大的遞增排序。
1.	將變數pivot設為數列的第一數值，index指標同樣指向數列的第一數值，k指標向右訪尋直到數列最後一個值。
2.	當k指標訪尋到某個數值小於pivot時，index指標向右移一格，並且index指標所指到的數值與k指標所指到的數值對調。
3.	k指標繼續向右訪尋，直到數列最後一個值為止。當k指標訪尋到某個數值小於pivot時，index指標向右移一格，並且index指標所指到的數值與k指標所指到的數值對調。
4.	當k指標訪尋完畢後，pivot值與index指標所指向的值對調。pivot將變為數列的中間值，將數列分成左右兩個子數列。小於中間值的資料在左邊，大於中間值的資料在右邊。
5.	接著分別在左右兩個子集合內做step1~step4的動作，直到完成排序為止。
  
以下為其程式碼的邏輯:
A.	定義函式sortQuick()來執行排序。
B.	以遞迴呼叫本身的函式，分別處理左邊和右邊的元素。
C.	定義函示Division()來執行快速排序法的分割動作。指定數列第一個數值作為pivot，指標index最初也指向pivot。依據指標k指向的值和pivot做比較來決定是否要換位置，當k指向的值小於pivot，指標index向後移動一位，k所指向的值與index所指向的值對調，指標k再繼續向後訪尋；當指標k移動到數列最後一個數值並且所指向過的數值也都與pivot比較過後，pivot將與指標index所指向的數值對調。此時pivot將會成為該數列的中間值，該中間值將數列分成左右兩個子數列，位於中間值左邊的數列均小於中間值；位於中間值右邊的數列均大於中間值。同時函示Division()還會回傳中間值在數列的位置。
D.	左右兩個子數列再透過遞迴呼叫本身的函式各自進行排序。




